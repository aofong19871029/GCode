## TCP UDP



TCP 与 UDP的区别

### 相同:

1. 都是传输层的协议

2. 同属于IP协议族

3. 打包和拆包，顺序一样

   打包:  应用层->传输层->网络层->数据链路层
   拆包: 数据链路层->网络层->传输层->应用层



### 不同

1. TCP提供的是面向连接的、可靠的数据流传输， 不重不漏不丢失， 按顺序到达

   连接时需要3次握手

   1、客户端发送请求【寻址请求】
   2、服务器端收到报文请求，回应客户端【确认请求】
   3、客户端收到服务端的报文进行回应。【连接请求】

   断开时4次挥手

   1、数据验证请求码
   2、传输结束标记
   3、确认结束标记
   4、连接断开标记

   UDP 是无连接的，不可靠性，尽最大努力交付，但不保证可靠交付

2. 由于tcp是面向连接的，所以只能点到点的通信，不支持1对多， 多对1和多对多的广播

   UDP由于其无连接特性， 可以支持各种广播

3. TCP 首部开销20字节， UDP只有8字节

   UDP头部: 源端口、目的端口、长度和校验码

   TCP头部:  16位端口号,  32位序号, 32位确认号，4位头部长度

4. 对数据准确和顺序有要求， 同时可以允许速度较慢的场景使用TCP (文件， email, http)，

   如果要求实时性的场景选用UDP（ping, im, 会议）， 工作效率高

5. TCP支持全双工通信， UDP只支持1v1, 1vn, nvn, nv1广播模式

6. 报文格式不同

   TCP 与上层协议的传输使用字节流的形式

   UDP 使用的数据报的模式, 保留报文边界（结构更简单）

7. TCP 为了保证接收端来得及接收， 利用滑动窗口做流量控制

   为保证传输的网络性能，TCP实现了拥塞控制功能，基于4种算法(慢开始，拥塞避免，快重传，快恢复)

   ![拥塞窗口](https://img-blog.csdnimg.cn/20190731184935595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)

   `慢开始`: 初次窗口值(cwnd)为1, 每一轮成功传输后，窗口值以2倍放大，直到达到阈值（门限值ssthresh）

   `拥塞避免`: 每个传输轮次，窗口值只能线性+1, 如果发现传输丢包，窗口重新设置为1 重新进入`慢开始`

   `快速重传`: 发送方尽快进行重传，而不是等待重传计时器超时再传.

   快重传后，如果发送方收到少量的重复确认，就知道只是个丢失个别报文，就不用启动`慢开始`, 而是启用`快恢复`

   `快恢复`：发送方，将`慢开始`的开始门限和拥塞窗口cwnd 调整为当前的一半，继续执行`拥塞避免`

8. 基于第7点，TCP消耗的资源比UDP多

## HTTP

### http 1.0

* 无状态
* 默认端口80

- 请求与响应支持 HTTP 头，响应含状态行，增加了状态码，
- 支持 HEAD，GET, POST 方法
- 支持传输 HTML 文件以外其他类型的内容
- 使用短连接, 每次请求需要重新建立TCP连接， 增加的网络负担

### http 1.1

* 支持长连接
  ajax 模拟
  long poll Connection:keep-alive 
  优点: 减少客户端请求，降低无效传输, 
  缺点: 无法处理高并发

* 引入了请求范围设置，优化了带宽

* 在错误通知管理中新增了错误状态响应码

* 加了Host头处理，可以传递主机名（hostname）

* 明文传输

* 在HTTP1.0的基础上引入了更多的缓存控制策略。（协商缓存和强制缓存）

  缓存的优点:

  * 减少了不必要的数据传输，节省带宽
  * 减少服务器的负担，提升网站性能
  * 加快了客户端加载网页的速度
  * 用户体验友好

  缺点:

  * 资源如果有更改但是客户端不及时更新会造成用户获取信息滞后，如果老版本有bug的话，情况会更加糟糕。

  强缓存总结：
  设置一个过期时间， 其中1，2都会在用户做了刷箱操作后, 就是资源没过期，浏览器也会请求服务器

  1. cache-control: max-age=xxxx，public
     客户端和代理服务器都可以缓存该资源；
     客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，如果用户做了刷新操作，就向服务器发起http请求
  2. cache-control: max-age=xxxx，private只让客户端可以缓存该资源；代理服务器不缓存
     客户端在xxx秒内直接读取缓存,statu code:200
  3. cache-control: max-age=xxxx，immutable
     客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求
  4. cache-control: no-cache
     无强缓存，如果设置了协商缓存，则继续执行协商缓存
  5. cache-control: no-store
     客户端和服务器都不缓存，协商缓存也无效
  6. Expires
  
  协商缓存：
  
  协商缓存需要客户端和服务器交互, 
  
  `发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->没过期-->返回304状态码-->客户端用缓存的老资源`
  
  etag：每个文件有一个，改动文件了就变了，就是个文件hash，每个文件唯一，就像用webpack打包的时候，每个资源都会有这个东西，如： app.js打包后变为 app.c20abbde.js，加个唯一hash，也是为了解决缓存问题。
  
  last-modified：文件的修改时间，精确到秒， 如果是秒以下的修改频繁都就用etag

### http2.0

* 多路复用
  在一个tcp中完成多个http请求， 变相规避了浏览器同域请求数的限制. 如果网络发生切换，TCP会断开，浏览器会重连.
  tcp内的多个http请求并行异步发送，不用等待前面一个返回
  
* 二进制分帧
  HTTP/2在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段的情况下。 将信息，拆分为更小的消息和帧, 采用二进制编码，避免了之前单http包太大，导致网络拥堵，进入`慢启动`

* 首部压缩
  SPDY使用DEFLATE算法，H2单独开发HPACK算法
* Server Push
  h2中服务端可以对客户端一个请求，发送多次响应, 这点可以用来优化，比如csr后，服务把数据和资源文件跟着push过来 

### http3.0 （quic）
* 放弃了TCP, 基于UDP实现
* 上层使用Google开发的QUIC , 来实现TCP的可靠传输， 拥塞控制， 加密，多路数据流

### https

* 基于HTTP 协议， 通过SSL or TSL提供数据加密
* 默认端口443
* https的三次握手
  * client 发送请求连接server:443, 发送随机值1+客户端支持的加密算法(公钥加密)
  * server收到消息，返回client 随机值2+加密算法（前一个的子集， 公钥）
  * server 给client发送第2个响应 证书（公钥）
  * client TLS 解析证书， 验证公钥是否有效， 机构，过期时间，签名算法等
  * client 将 随机值1 + 随机值2 + 预主装密钥 组成`会话密钥` 通过证书公钥加密，发送给server
  * 服务端使用证书私钥解密，得到`会话密钥`与客户端相同
  * 然后client server 在通过会话密钥来加密消息，完成传递

  

