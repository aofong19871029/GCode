## 咱们设计的CALLBACK_LIST是否有意义？ 这种情况下有用码？什么时候有用

```js
const test = new MPromise((resolve, reject) => {
    setTimeout(()=>{
        resolve(111)
    }, 1000)
}).then(value=>{})
.then(value=>{})
.then(value=>{})
.then(value=>{})
.then(value=>{})
.then(value=>{})
.then(value=>{})
.then(value=>{})
.then(value=>{})
```

1. 这种情况下没用,因为每一个.then返回的都是新promise实例，新实例里callback数组初始化为空数组了
2. 这种设计有意义
3. 下面这种情况才有意义

```js
const test = new MPromise((resolve, reject) => {
    setTimeout(()=>{
        resolve(111)
    }, 1000)
});
// 这里就产生了2个promise
// test是原始了
// test.then返回的是另外一个
test.then(value=>{})
.then(value=>{})
.then(value=>{})
.then(value=>{})
.then(value=>{})
.then(value=>{})
.then(value=>{})
.then(value=>{})
.then(value=>{})
```



## 为什么在catch回调是pending, 最后是fulfilled

```js
const test = new MPromise((resolve, reject) => {
    setTimeout(()=>{
        reject(111)
    },1000)
}).catch(reson => {
    console.log(test) // pending
})

setTimeout(()=>{
    console.log(test) // fulfilled
}, 3000)
```

1. 需要关注的是reject掉的是最初的promise , 而test是.catch 返回的新的promise, 而.catch回调函数正常执行完成了，没有报错，所以这个新的promise是fulfilled.
2. .catch打印console.log的过程，其实是执行回调函数的过程中，而只有回调函数执行完成了，无论是正常的还是报错, promise2才有1个新结果