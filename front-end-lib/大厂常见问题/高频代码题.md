# 2021大厂前端高频代码题

面试官提出问题 vue双向绑定原理



1. 和前端技术相关的代码题 / 数据格式转换
2. 纯算法题



## 前端技术相关的代码题

### 1. 你了解vue的双向绑定原理？

所谓的双向绑定，是建立在MVVM模型的基础上

* 数据层 Model: 应用的数据以及业务逻辑
* 视图层 View: 应用的展示效果，各类的UI组件等
* 业务逻辑层 ViewModel: 负责将数据和视图关联起来



1. 数据变化后更新视图
2. 视图变化后更新数据

包含两个主要的组成部分

* 监听器Observer: 对所有的数据属性进行监听
* 解析器Compiler: 对每个元素节点的指令进行扫描和解析，根据指令替换数据，绑定对应的更新函数

#### 具体的实现原理

1. new Vue() 执行初始化，对data通过Object.defineProperty进行相应化处理，这个过程发生在Observer中，每个key都会有一个dep实例来存储watcher实例数组.
2. 对模板进行编译时，v-开头的关键词作为指令解析，找到动态绑定的数据。从data中获取数据并初始化视图，这个过程在Compiler里。如果遇到v-model, 就监听input事件，更新data对应的数值
3. 在解析指令的过程中，会定义一个更新函数和watcher, 之后对应的数据变化时watcher会调用更新函数.new watcher的过程中去读取data的key, 触发getter的依赖收集，将对应的watcher添加到dep里
4. 将来data中数据一旦发生变化，会首先找到对应的dep,通知所有的watcher执行更新函数.

#### Coding

1. 来简单实现一个响应式函数？ 对一个对象内的所有key添加响应式的特性?

   ```js
   const render = (key, val)=>console.log(`SET key=${key} val=${val}`)
   
   const defineReactive = (obj, key, val) => {
   	reactive(val);
       
       Object.defineProperty(obj, key, {
             get(){
       		return val;    
   	    },      
           set(newVal){
               if(val === newVal){
                   // 模拟diff
                   return;
               }
   
               val = newVal;
               render(key, val);
           }
        })
   }
   
   const reactive = (obj) => {
       // 可以作为一个递归的中止条件
       if(typeof obj === 'object'){
           for(const key in obj){
               defineProperty(obj, key, obj[key]);
           }
       }
   }
   
   const data = {
       a: 1,
       b: 2,
       c: {
           c1: {
               af: 999
           },
           c2: 4
       }
   }
   reactive(data);
   
   data.a = 5 //SET key=a val=5
   data.b=7 // SET key=b val=7
   data.c.c2=4 // 无变动
   data.c.c1.af=121 //SET key=af, val=121
   ```

   

2. 那Vue中对于数组类型是怎么处理的？你能简单模拟下对于数组方法的监听吗？

```js
const render = (action, ...args) => {
    console.log(`Action=${action}, args=${args.join(',')}`);
}

// 保存原原型链
const arrProperty = Array.prototype;
// 建立新链
const newArrPrototype = Object.create(arrProperty);

['push', 'pop', 'shift', 'unshift', 'sort', 'splice', 'reverse'].forEach(methodName => {
    newArrPrototype[methodName] = function(){
        // 执行原有数组的方法
        arrProperty[methodName].call(this, ...arguments);

        render(methodName, ...arguments);
    }
})

const reactive = (obj) => {
    if(Array.isArray(obj)){
        obj.__proto__ = newArrPrototype;
    }
}

const data = [1,2,3,4];
reactive(data);

data.push(5) // Action = push args=5
data.splice(0,2) //Action=splice, args=0,2
```



3. 能否监听对象属性的删除操作？基于Proxy实现响应式

```js
const observeStore = new Map();

function makeObservable(target) {
    let handlerName = Symbol('handler');
    observeStore.set(handlerName, [])

    target.observe = function(handler){
        observeStore.get(handlerName).push(handler)
    }

    const proxyHandler = {
        get(target, property, receiver){
            if(typeof target[property] === 'object' && target[property] != null){
                return new Proxy( target[property], proxyHandler);
            }


            let success = Reflect.get(...arguments);

            if(success){
                observeStore.get(handlerName).forEach(handler =>
                    handler('GET', property, target[property]))
            }

            return success;
        },
        set(target, property, value, receiver){
            let success = Reflect.set(...arguments);

            if(success){
                observeStore.get(handlerName).forEach(handler =>
                    handler('SET', property, target[property]))
            }
            
            return success;
        },
        deleteProperty(target, property){
            let success = Reflect.deleteProperty(...arguments);

            if(success){
                observeStore.get(handlerName).forEach(handler =>
                    handler('DELETE', property))
            }
            
            return success;
        }
    }

    return new Proxy(target, proxyHandler);
}

let user = {};
user = makeObservable(user);

user.observe((action, key, value) => {
    console.log(`${action} key=${key} value=${value || ''}`)
})

user.name='John' // SET key=name value=John
console.log(user.name) // GET key=name value=John
delete user.name // DELETE key=name value=
```

### 2. 你了解虚拟DOM吗? 能说以下他的优缺点吗？

视频https://www.bilibili.com/video/BV1EF411h71G?from=search&seid=17382819655542645948&spm_id_from=333.337.0.0  1：06

