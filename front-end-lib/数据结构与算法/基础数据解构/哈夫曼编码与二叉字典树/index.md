## 哈夫曼编码与二叉字典树

普通字典树下面有26个叉

#### 什么是编码

* 思考一个问题

在计算机如何表示`a`

a  ---------> 01100001

A ----------> 01000001

0 ----------> 00110000

#### 定长编码与变长编码

定长与变长是看具体的实现算法。

- 定长编码------ASCII 编码

字节是计算机中存储数据的最小单位，一个字节8位二进制， ASCII一个字符占一个字节

```c++
printf("%c", 'a')             'a' 人类可见
printf("%d", 'a') //十进制     97
printf("%X", 'a') //十六进制   61
```

```
01100001 | 010000001 | 00110010 | 00110000 8位对应一个字符解码为aA20
```

定长编码的好处

1: 好编码

2: 好解码

但是容易浪费字节，补0

- 变长编码

变长编码的算法，输出的编码长度不一定不同。

**有效的变长编码：**

**字符的编码，不能是其他字符编码的前缀**

​                         **如果把编码看成二叉树上的路径**

​                         **所有字符，均落在叶子节点上**

```
a->0
A->00
0->000
分隔符 1  
010010001001 -> aA0A

a: 01   
A: 10 
0: 11
二叉树左树为0， 右树为1
      r
  0 /   \ 1
  0/\1 0/ \1
     a  A  0
    
```

* 为什么会有变长编码

  场景：网络传输800位/秒

  1. ACSII 8x100 = 800， 1s 传输800二进制位， 100个字符

  2. 信息中只包含a b c d, 其中出现概率分别是 50%, 30%, 10%， 10%
     a: 0.5  --> 1           0.5+ 0.3x2+0.1x3+0.1x3  ===>

     b: 0.3  --> 00        0.5+0.6 + 0.6 = 1.7

     c: 0.1  ---> 010   1.7x100=170/800  0.2125s  这样传100个字符只需要0.2s , 提高信息的传输效率   
     d: 0.1 ---> 011

**变长编码的算法可以提高信息的传输效率， 变长编码算法效率>=定长编码**

#### 哈夫曼编码

最牛逼的变长编码

```
a: 0.2
b: 0.1
c: 0.3
d: 0.4
e: 0.1
```



1. 统计字符出现的频率

2. 建树，每一次，选择频率最低的2个节点，组成新的子树

   ```
        0.2
    /        \
   (0.1)b   (0.1)e
   ```

   

3. 再选2个概率最低的

   ```
           1.1
          /   \
    0.7       0.4
     /\        / \
   c   d      a   0.2
   00  01     10   /\
                  b  e
                 110 111
   ```

   

4. 提取编码。 相应的字符都在叶子节点， 按照左边为0， 右子树为1

5.  a: 10          00  01  111 110 10 01 
    b: 110         c   d    e    b      a     d
    c: 00
    d: 01
    e: 111

  如何评价哈夫曼算法最优？ 

  通过计算平均编码长度指标
$$
L = \sum_{i-1}^nli*p_i
$$
leetcode 刷题: 1:53



